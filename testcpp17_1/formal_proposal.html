<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>A Proposal to Add split/join of string/string_view to the Standard Library</TITLE>
    <META http-equiv=Content-Type content="text/html; charset=windows-1252">
</HEAD>
<BODY>
    <p style="font-size:small ">
        Laurent NAVARRO &lt;ln@altidev.com&gt; <BR>2016-12-28
        <BR>Doc number  TBD
        </p>

        <H1>A Proposal to Add split/join of string/string_view to the Standard Library </H1>


        <H2>I. Motivation</H2>

    <p>
        Split a string in multiple string based on a separator and the reverse operation to aggregate a collection of string with separator are quite common operations
        , but there's no standardized easy to use solutions in the existing <code>std::basic_string</code> and the proposed <code>std::basic_string_view</code> class.
    </p>
    <p>The purpose of this simple proposal is to cover this miss.</p>
    <p>
        This feature is available in the standard string class of the following languages : D, Python, Java, C#, Go, Rust.
    </p>


    <H2>II. Impact On the Standard</H2>

    <p>
        This proposal is a pure library extension. It does not require changes in the language core itself.<br>
        It does require adding new method to <code>std::basic_string</code> class (or not if implemented only in <code>std::basic_string_view</code>). <br>
        Or just a function add in algorithms if this option is preferred.
    </p>
    <p>It has been implemented in standard C++.</p>


    <H2>III. Design Decisions</H2>

    <P>Several options have been discussed in this discussion <a href="#Ref1">[1]</a>, bellows a summary of the various discussed options</P>

    <H3>Discussion on split</H3>
    <H4>splits &amp; splitsv method</H4>
    <p>
        Probably the simplest option is to add method to <code>std::basic_string</code> and <code>std::basic_string_view</code>.<br>
        Example on <code>std::basic_string_view</code> (<code>std::basic_string</code> is quite the same)
        <pre>vector&lt;basic_string&lt;CharT, Traits> > splits(const basic_string_view&lt;CharT, Traits> &Separator) const
vector&lt;basic_string_view&lt;CharT, Traits> > splitsv(const basic_string_view&lt;CharT, Traits> &Separator) const </pre>
        The purpose of theses method is to return a vector of string or of string_view.<br>
        It's decided to hardcode the vector choice to have a call as simple possible.
        <pre>auto MyResult= "my,csv,line"s.split(",");</pre>
        <code>s</code> and <code>sv</code> suffixes are derived from the normalized literal suffixes.<br>
        <code>splitsv</code> has the advantage to be efficient in terms of CPU (no copy to do) and RAM (No memory to allocate for substring, just for the vector).<br>
        <code>splits</code> is useful if <code>splitsv</code> can't be used. For instance, it's needed if you try to split a temporary object.<br>
        Move semantic is used to optimize the returned vector.<br>
        Example of implementation in <a href="#Ref2">[2]</a> (could be optimized with an initial parsing to reserve the vector)
    </p>

    <H4>basic_string_view implementation only</H4>
    <p>
        Several options presented here are method in both <code>std::basic_string</code> and <code>std::basic_string_view</code>.
        It could make sense to implement them only in <code>std::basic_string_view</code> for several reasons :
        <ul>
            <li>The implementation is similar for both</li>
            <li>string can easily (and with a very small cost) be converted on string_view</li>
            <li><code>basic_string_view</code> is a new class then it's probably simpler to amend it to integrate theses features in C++ 17. Could be back ported later on <code>std::basic_string</code> if needed.</li>
        </ul>
    </p>

    <H4>splitf method</H4>
    <p><code>splitf</code> method will split the input string and call an unary functor with a <code>std::basic_string_view</code> as a parameter</p>
    <pre>template &lt;class F>
void splitf(const basic_string_view<CharT, Traits> &Separator,F functor) const</pre>
    <p>
        Some person does not wish to have a container returned to avoid its memory allocation, <code>splitf</code> is one possible method to address this concern.<br>
        Some person wishes to execute a processing on each value, <code>splitf</code> is a more direct way to address this request than iterate on <code>splitsv</code> result.<br>
        The transmitted string view allows compute the position of the substring in the initial string, it was highlighted as a potential need.<br>
        Example of usage displaying substring, initial position and length<pre>
strsv.splitf(" ", [&](const string_view &s)
	{ cout &lt;&lt; s &lt;&lt;"   ,Pos="&lt;&lt;(s.data() -strsv.data())&lt;&lt;" ,Len="&lt;&lt;s.length()<< endl; }
);</pre>
        Example of implementation in <a href="#Ref2">[2]</a> 
    </p>

    <H4>splitc method</H4>
    <p><code>splitc</code> method will split the input string and push substring in the container passed as output parameter</p>
    <pre>template &lt;class T>
void splitc(const basic_string_view&lt;CharT, Traits> &Separator,T &Result) const</pre>
    <p>
        Some person does not wish to use a vector container, this option allows transmit a wide range of containers to address this concern.<br>
        This option also allows feed a container with another string type in it. Can be done in this way if it can be built from a string_view.<br>        
        Example of usage<pre>
vector&lt;string_view> vector5;
strsv.splitc(" ", vector5); 
vector&lt;string> vector6;
strsv.splitc(" ", vector6);     </pre>
        Example of implementation in <a href="#Ref2">[2]</a> 
    </p>


    <H4>string_split function</H4>
    <p>
        <code>string_split</code> function algorithm will return a range and can potentially replace all the previously discussed method<br>
        Example of usage<pre>
string MyStr("my,csv,line")
vector&lt;string>  MyResult(split(MyStr, ","));
// Efficient conversion from string to string_view may require an explicit initial casting
vector&lt;string_view> MyResult(split(string_view(MyStr), ","));
// splitf replacement
std::for_each(split(string_view(MyStr), ","), callback);    </pre>
It could also be used with alternate string class, however it will probably require they have a standardized way to extract substring by having a substr method 
        (it's not case of qstring, Cstring, AnsiString ) making this argument less valuable<br>
Example of implementation in <a href="#Ref3">[3]&[4]</a><br>
It looks at a smart option, however, some cons on it :<br>
* Temporary object issues (see below)<br>
* Some notation may be heavier than with methods options<br>
* Create a global name function which could have a collision with existing code.
    </p>
    <p><a name="TempObject"><span style="text-decoration: underline;">The Temporary object issue</span></a><br>
        During the evaluation of prototype it was clearly appears there's a problem with temporary objects.<br>
<pre>string string_toLower(string Str)
{
    std::transform(Str.begin(), Str.end(), Str.begin(), ::tolower);
    return Str;
}
int main()
{
  for(auto x : split_string(vstr1,regex("\\s")))      <== (1)
    . . . . .
  for(auto x : split_string(string_toLower("C++ Is Very Fun!!!")," "))    <== (2)
    . . . . .
}    </pre>
Code (1) will not work because <code>split_string</code> use a reference to the <code>regex</code> but has this one doesn't exist anymore when
    <code>split_string</code> returns, the returned iterator got a problem because the regex object doesn't exist anymore.<br>
    It can easily be fixed by copying the regex in the iterator, but it's not cost free. Problem is potentially the same with the string separator but has it should be a literal it should be OK in most times.
    </p>
    <p> Code (2) will not work either and it's a bigger problem. It's for the same reason, when we use the returned iterator, the lowered string doesn't exist anymore.
      But systematically make a copy of the inputString doesn't make sense from a memory and a performance perspective.
      It will also invalidate returned string_view in several other usage as the returned string view will not be on the initial object but on the saved copy.
    </p><p>
    <span style="text-decoration: underline;">Solutions Comparison</span><br>
      Since the first answer in the proposal thread on google groups, there's a debate between methods vs function. Bellow a factual comparison on some use case.
<style>
#table1 td:nth-child(2),#table1 td:nth-child(3) {font-family: Menlo, Monaco, Consolas, "Courier New", monospace;font-size: small;min-width: 300px;}
</style>
    <table border="1" id="table1">
      <tr>
        <th>Usage</th>
        <th>Function Option</th>
        <th>Method Option</th>
        <th>Remarks</th>
      </tr>
      <tr>
        <td>Split in vector of string_view</td>
        <td>vector&lt;string_view> vec =string_split(str,",");</td>
        <td>auto vec=str.splitsv(",");</td>
        <td>Function solution allocate 1 extra split_range_string and 3 extra iterators (first_,past_last_,the internal of for) </td>
      </tr>
      <tr>
        <td>Split in vector of string</td>
        <td>vector&lt;string> vec=string_split(str,",");</td>
        <td>auto vec=str.splits(",");</td>
        <td>Function solution allocate 1 extra split_range_string and 3 extra iterators (first_,past_last_,the internal of for) +creation of intermediate string_view </td>
      </tr>
      <tr>
        <td>Split in list of string_view</td>
        <td>list&lt;string_view> lst =string_split(str,",");</td>
        <td>list&lt;string_view> lst;<br>
          str.splitc(",",lst);</td>
        <td>Function solution use the same notation for every container.<br>
          Method solution requires a different coding for other containers but is more efficient as it doesn't require extra object creation.
        </td>
      </tr>
      <tr>
        <td>Split over a function</td>
        <td>for_each(string_split(str,","),MyFunction);</td>
        <td>str.splitf(",",MyFunction);</td>
        <td>Function solution allocate extra objects </td>
      </tr>
      <tr>
        <td>Split over a loop (a)</td>
        <td>for(s :string_split(str,","))</td>
        <td>for(s :str.splitsv(","))</td>
        <td>Methods solution allocate an extra vector of string_view  </td>
      </tr>
      <tr>
        <td>Split over a loop (b)</td>
        <td>for(s :string_split(str,","))</td>
        <td>	strsv.splitf(" ", [&](const string_view &s)	{<br>
		cout &lt;&lt; s &lt;&lt; endl; <br>
	});
</td>
        <td>Methods solution doesn't allocate the extra vector and no extra object like function solution but the notation is quite less conventional </td>
      </tr>
      <tr>
        <td>Temporary object</td>
        <td>vec=string_split(GetTmpObject(),",");</td>
        <td>vec=GetTmpObject().split(",");</td>
        <td>
          Function solution : Doesn't work (see § Temporary object issue)<br>
          Methods solution : works fine
        </td>
      </tr>
      <tr>
        <td>From alternate string class (Must be convertible with string_view)</td>
        <td>vec=string_split(MyOtherString,",");</td>
        <td>vec=string_view(MyOtherString).split(",");</td>
        <td>
          both options use in fact the string_view implementation. string_split is not instanciated for the alternate string class.
        </td>
      </tr>
    </table>
    </p>


    <H4>split by single char</H4>
    <p>It was highlighted that split by a single char can be optimized regarding splitting by a string. Then it was suggested an overload for single char Separator.<br>
    On the other hand this optimization can be detected at runtime or by a non-standardized overload.<br>
    However the find method as standardized this kind of overload.</p>
    <p>
        Perhaps the best option is to let the separator as generic type as it allows use specialized version of <code>find</code> and let implementors overload it they want to optimize it.<br>
        On the other hand, specify it as part of the standard is an incitation to optimize it and is perhaps good too as it's probably the most common case.
    </p>
    <p> So debate it's not yet closed <br>
        Example of implementation in <a href="#Ref2">[2]</a>         
    </p>


    <H4>split by regexp</H4>
    <p>
        It was highlighted that split by a regexp can be useful, it can also be a way to implement the split by a set of separators, then an overload of <code>split</code> with <code>regexp</code> could make sense.
</p><p>
    If selected option for split is function it may be an overload of this function located on the regexp header.<br>
    Or it can be a similar but different function named regexp_split to be consistent with other regex algorithms (regex_match, regex_search, regex_replace)
</p><p>
    If selected option for split is methods, it may introduce a dependency on regexp which is perhaps not a good idea.<br>
    But it could be implemented by a regexp_split function. <br>
    Perhaps it's not an issue to have a dependency with another standard class in this case overload on function may make sense.
</p><p>
    So debate it's not yet closed and depends on the conclusion of the selected option between string::split methods and range string_split function<br>        
    </p>


    <H4>split by splitter object</H4>
    <p>
    It N3593 Proposal <a href="#Ref5">[5]</a> there's the idea of using a template delimiter object which must implement a find method.<br>
    The proposal suggests providing 4 built-in classes for char,string,any_of_string,regex.<br>
    It's a smart idea as it allows reduce the number of overload and provide the possibility to extend the concept.<br>
    However I think that the benefit provided by reduction of overload is lost by the introduction of 4 new classes. And the wish to add a new kind of splitter is reduced.<br>
    Then I consider this solution is a bit more complex for a reduced benefit.
    <p>

    <H3>Discussion on join</H3>


    <H4>join static method</H4>
    <p><code>join</code> static method will join a list of input string transmitted on a iterable container and add a delimiter between each value</p>
    <pre>template&lt;class T,class U>
static basic_string&lt;CharT, Traits, Allocator> join(T &InputStringList, U Separator)</pre>
    <p>

    Example of usage (simple but so useful)<pre>
cout << "Join of string vector=" << string::join(vector6, "_") << endl;
cout << "Join of string_view vector=" << string::join(vector5, "_") << endl;    </pre>
        Example of implementation in <a href="#Ref2">[2]</a> 
</p>

    <H4>join method</H4>
    <p><code>join</code> method will use the current string as a separator to join the list, it's the way of usage of join in Python</p>
    <pre>template&lt;class T>
	basic_string&lt;CharT, Traits, Allocator> join(T &InputStringList)</pre>
    <p>
        Example of usage <pre>
cout << "pythonic Join of string =" << "-"s.join(vector6) << endl;
    </pre>
This option could also be part of <code>std::basic_string_view</code> class, the static option make less sense.
<br>Example of implementation in <a href="#Ref2">[2]</a> 
    </p>

    <H4>string_join function</H4>
    <p><code>string_join</code> function act exactly as static function but is more adequate if <code>string_split</code> function is the selected option for split.</p>
    <pre>template&lt;class T,class U>
basic_string&lt;typename T::value_type::value_type, typename T::value_type::traits_type> string_join(T &InputStringList, U Separator)</pre>
    <p> Example of usage (simple but so useful)<pre>
cout << "Join of string_view vector with string_join=" << string_join(vector5, "_") << endl;</pre>
        Example of implementation in <a href="#Ref2">[2]</a> 
    </p>

    <H4>Processing optimization</H4>
    <p>It's possible to optimize the processing by iterating on the container a first time to compute the size of the final string and reserve it below an example on </p>
    <pre>template&lt;class T>
basic_string&lt;typename T::value_type::value_type, typename T::value_type::traits_type> 
  string_join(const T &InputStringList
            , const basic_string_view&lt;typename T::value_type::value_type,typename T::value_type::traits_type> Separator)
{
	basic_string&lt;T::value_type::value_type, T::value_type::traits_type> result_string;
	size_t StrLen = 0;	
	if (InputStringList.empty())
		return result_string;
	auto it = InputStringList.begin();
	for (; it != InputStringList.end(); ++it)
		StrLen += it->size() + Separator.size();
	result_string.reserve(StrLen);
	result_string += *InputStringList.begin();
	for (it = ++InputStringList.begin(); it != InputStringList.end(); ++it)
	{
		result_string += Separator;
		result_string += *it;
	}
	return result_string;
}</pre>
    <p>
        However it implies to be able to obtain the length of each string in both InputStringList and Separator. 
        We can consider it's quite common that the separator will be a <code>char*</code> but it doesn't have <code>size()</code> member, so as a workaround the separator is specified as <code>const string_view</code>.<br>
        The problem is the same if <code>InputStringList</code> is a <code>vector&lt;char*></code>, but in this case the problem is bigger as it seems to me impossible to specify the type of the returned string.
    </p>


    <H4>Parameter order</H4>
    <p>In several function like string_join it was highlighted the  order could be with the separator first as it's smaller than the container (or the input string).</p>
    <p> In some language the standard implementation is with the separator first :  PHP , C#, Java<br>
In some others, it's separator last Go, Rust, boost::algorithm::join, LibC strtok<br>
        Python has a different logic as the separator is the "caller" object (like join classic method described earlier)<br>
        Having the separator as 2nd parameters would allow have it optional with "" <br>
        It has to be analyzed later, but the consensus seems to be for the separator last.
    </p>

    <H2>IV. Proposed Text</H2>
    <p>TBD when a consensus on better options will be reached. </p>
            

    <H2>VI References</H2>

    <ul>
    <li>
    <a name="Ref1">
                        [1] Discussion on Google Groups</a>
    <a href="https://groups.google.com/a/isocpp.org/forum/?utm_medium=email&utm_source=footer#!topic/std-proposals/JTKTThJ-7Ko">https://groups.google.com/a/isocpp.org/forum/?utm_medium=email&utm_source=footer#!topic/std-proposals/JTKTThJ-7Ko</a>                    
                </li>
    <li><a name="Ref2">
      [2] Example of implementation on GitHub with GCC 6.2 MingW</a>
      <a href="https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_1/testongcc.cpp">https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_1/testongcc.cpp</a>
    </li>
    <li><a name="Ref3">
      [3a] Implementation prototype done for N3593 Proposal</a>
      <a href="https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_3/StringSplit.h">https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_3/StringSplit.h</a>
    </li>
    <li>
      [3b] Test code of implementation prototype done for N3593 Proposal
      <a href="https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_3/TestStringSplit.cpp">https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_3/TestStringSplit.cpp</a>
    </li>
    <li><a name="Ref4">
      [4] Example of implementation by range initiated by Nicol and amended by Laurent on GitHub</a>
      <a href="https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_3/RangeSplitTest.cpp">https://github.com/laurent-n/cpp17_implode_explode/blob/master/testcpp17_3/RangeSplitTest.cpp</a>
    </li>
    <li><a name="Ref5">
      [5] N3593 Proposal</a>
      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3593.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3593.html</a>
    </li>

  </ul>
</BODY>
</HTML>